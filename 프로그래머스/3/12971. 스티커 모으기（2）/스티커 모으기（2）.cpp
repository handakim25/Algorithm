#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 일단 개수를 봐서는 완전 탐색은 불가능하다.
// 이러한 상황에서 사용할 수 있는 방법은 DP, 탐욕법이다.
// 다만 첫번째 방법에서부터 14가 빠진 것을 봐서는 탐욕법으로는 풀이가 안 될 것으로 생각된다.
// 그렇다면 동적 계획법인데 이러한 문제는 n번째를 포함했을 때의 최대 문제로 정의된다.
// 비슷한 유형의 문제가 많은데 관련된 문제를 모아서 정리해둘 필요가 있다. 시간 남으면 Lv2, 3 풀었던 문제들 유형 정리해서 한 번에 정리할 것.

// f(n)의 상황을 생각해보자. n 번째를 포함하게 되면 n - 1의 값은 포함할 수 없다. 이 상황에서의 최대값은  n - 2와 n번째를 합한 값이다.
// n번째를 포함할 수 없으면 n - 1이 최대값이다.
// 이를 수식으로 세우면
// f(n) = max(f(n - 2) + f(n), f(n - 1))
// fix1. f의 값과 arr의 값은 다른 건데 이것을 섞어서 고려했다. 이러한 문제를 자주 풀지 않으니까 실수한 건데 수식 검증에 주의할 것
// -> f(n) = max(f(n - 2) + a(n), f(n - 1))

// 동적 계획법 - step2
// 초기값을 설정해야 한다.
// f(1) = arr[1], f(2) = max(arr[1], arr[2])
// 문제는 배열의 범위이다. 첫번째 포함되면 마지막 원소가 포함될 수 없다.
// 일단은 문제를 첫번째 포함하고, 제외하고 나누어서 풀이를 해야될 것 같다. 통합되게 풀이할 수 있을지는 잘 모르겟다.

// 굉장히 많은 수의 합이므로 int 범위 이내인지 파악을 해야 한다.
// 문제에서 이미 int 반환이므로 문제는 없을 것 같지만 확인은 습관적으로 해야 한다.
// 값이 100, 길이가 100,000이므로 10,000,000(천만) 단위가 된다. 천만 단위이면 int 범위 이내이다.

int solution(vector<int> sticker)
{
    int n = sticker.size();
    
    // 기저 조건
    if(n == 1) {
        return sticker[0];
    }
    if(n == 2) {
        return max(sticker[0], sticker[1]);
    }
    
    // case1. 첫번째 포함해서 고려할 경우
    // 초기값 설정
    // dp table을 그냥 n으로 설정하도록 한다. sticker랑 인덱스를 맞추는게 덜 헷갈릴 것 같다.
    vector<int> dp1(n, 0);
    dp1[0] = sticker[0];
    dp1[1] = max(sticker[0], sticker[1]);
    // f(n) = max(f(n - 2) + f(n), f(n - 1)), n번째 포함, n번째 포함하지 않을 경우 중에서 최대 값 선택
    // fix -> f(n) = max(f(n - 2) + a(n), f(n - 1))
    // 첫번째를 고려했으므로 가장 마지막은 고려하지 않는다.
    for(int i = 2; i < n - 1; i++) {
        dp1[i] = max(dp1[i - 2] + sticker[i], dp1[i - 1]);        
    }
    
    // case2. 첫번째 미포함해서 고려할 경우
    // 초기값 설정
    vector<int> dp2(n, 0);
    dp2[0] = 0;
    dp2[1] = sticker[1];
    // f(n) = max(f(n - 2) + f(n), f(n - 1))
    // fix -> f(n) = max(f(n - 2) + a(n), f(n - 1))
    // 첫번째를 고려하지 않았으므로 가장 마지막은 고려한다.
    for(int i = 2; i < n; i++) {
        dp2[i] = max(dp2[i - 2] + sticker[i], dp2[i - 1]);
    }
    
    return max(dp1[n - 2], dp2[n - 1]);
}